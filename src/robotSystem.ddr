RobotSystem robotSystem
                        
Event cmd : cmd(X) //per lo start e per lo stop da console (pagina 23 del pdf per spiegazione)
Event sensordata : sensordata(X)  //from SensorObserver
Event reachedsensor : reachedsensor(X) 
Event obstacle : obstacle(X) //from red button (obstacle from console) and from SensorObserver
//Event endmove : endmove //from a robot move         

Event inputcmd       : usercmd(executeInput(CMD)) //per il run da console
Event alarm          : alarm( obstacle, p( Distance, Angle  ) )
Event sonar 		 : p( Distance, Angle ) 
Event numOfSonar  	 : numOfSonar( N )

Context  ctxRadar      ip [ host="172.20.10.2" port=8033 ] -httpserver //192.168.137.1
EventHandler evhr for sonar, alarm, cmd, numOfSonar ;
Context  ctxSensorEmitter  ip [ host="172.20.10.4" port=8133 ] //192.168.137.2

Context ctxRobot ip [ host="172.20.10.4"  port=8079 ] //192.168.137.2
EventHandler evh for /*endmove,*/ alarm, obstacle, sensordata /*-print*/ { memo currentEvent for robot_actor };

QActor  radargui context ctxRadar {
	  	
	Rules {
		checknear( D,A ) :- eval( lt, D, 20 ), !, assert( obstacle(D,A) ). //TODO sostituire 20 con 40
		checknear( D,A ).
	}
	  
	Plan init normal         
		println("RADAR init the GUI ... ") ;     
		actorOp activateGui ;     
		switchToPlan doWorkMsgs      
	Plan doWorkMsgs 
		sense time(86400000) sonar -> continue;
		switchToPlan checkObstacle ;
		onEvent sonar : p(D,A) -> actorOp sendDataToGui( D,A ) ; 
		repeatPlan  
	Plan checkObstacle resumeLastPlan //TODO questo è da fare / controllare
		onEvent sonar : p(D,A) -> demo checknear(D,A) ;
		[ ?? obstacle(D,A)  ] emit reachedsensor : reachedsensor(X) //il robot ha raggiunto il sensore, emetto un evento per avvisarlo
}

QActor usercmdhandler context ctxRadar {
	
	Plan init normal        
		sense time(86400000) cmd, alarm -> continue, continue;
		onEvent cmd : cmd(start) -> switchToPlan handleStart;
		onEvent cmd : cmd(stop) -> switchToPlan handleStop;
 		onEvent alarm : alarm( obstacle, p(D,A) ) -> switchToPlan handleAlarm;
		//switchToPlan handleInput ;
		repeatPlan
     Plan handleStop resumeLastPlan
		println("sei dentro handleStop") 
		//TODO mandare lo stop al robot 
	Plan handleStart resumeLastPlan
		println("sei dentro handleStart") 
		//TODO mandare lo start al robot
	Plan handleAlarm resumeLastPlan
		println("alarm") ;
		sound time(2000) file('./audio/tada2.wav') 
}

QActor sensorsonar context ctxSensorEmitter {
	  
	Rules {
		/* THESE RULES ARE WRITTEN IN THE WorldTheory of the sensorsonar */
		/* CONFIGURATION */
		onRaspberry.
		mysonar( s1, coloryellow, "172.20.10.4" ).
    	//mysonar( s1, coloryellow, "192.168.137.2" ).
    	//mysonar( s2, colorred, "192.168.251.121" ).     
    	//mysonar( s3, colorgreen, "192.168.251.120" ).       
 	
		/* RULES */
		sonar(s1,330).
		sonar(s2,30).
	//	sonar(s3,150).  
    	numOfSonars(N) :- bagof(sonar(S,P), sonar(S,P), SonarList), length(SonarList,N).
    	setmyposition :- numOfSonars(N), assert( numOfSonars( N ) ), mysonar( SONAR, _, _ ), sonar( SONAR,POS ), assert( position( POS ) ).   
    	//obstacledata( p(D,POS) ) :- actorOpDone( _,D ), position(POS). //actorOpDone( _,d(D) ) TODO trovare un modo per passare solo la distanza e non tutta la stringa generata
	}

	Plan init normal     
		println("sensorsonar STARTS")  ;
    	[ !? onRaspberry ] actorOp startSonarC;
    	demo setmyposition ;  //depends on mysonar
    	[ !? position(POS) ] println( position(POS) );
    	[ !? numOfSonars(N) ]  println( numOfSonars(N) );
 		[ !? numOfSonars(N) ]  emit numOfSonar : numOfSonar(N) ;
    	[ !? onRaspberry ] switchToPlan workReal 
	Plan workReal 
		[ !? position(POS) ] actorOp getDistanceFromSonar(POS) ; //(1)  //Dati reali prelevati dal sensore
		[ ?? obstacledata( D,POS )] emit sonar : p(D,POS) ;
    	repeatPlan
}

Robot ioRobot QActor robot_actor context ctxRobot /*-i*/{
	          
	Rules {                     
		tforward(10000).
		tturnright(350).
		tturnleft(300).
	}
	
	Plan init normal
		actorOp createPi4jLed(23);
 		println("-------------");
 		println("ioRobot: A robot performs a move in reactive way (usercmd)"  )  ;
		println("The moves can be stopped by pressing a button on the http GUI"  )  ;
		println("-------------");
		switchToPlan reachedSensor;
		//switchToPlan startWalking;
  		println("---- FINE ----")
  		
  	Plan startWalking
   		println("startWalking");
   		//TODO aggiungere reazione a stop da console (usercmd)
   		[!? tforward(T)] robotForward speed(100) time(T) react event obstacle -> stopWalking or event alarm -> reachedSensor;
   		repeatPlan //ripete il plan all'infinito
   		
	Plan startWalking2
		println("startWalking2");
		[!? tforward(T)] robotForward speed(100) time(T) react event obstacle -> stopWalking;
		switchToPlan stopWalking
   		
	Plan stopWalking
		println("stopWalking");
		//printCurrentEvent;
		robotStop speed(1) time(1);
		println("ioRobot stopped");
		switchToPlan waitRepositioning
   	
   	Plan reachedSensor
   		println("reachedSensor");
		robotStop speed(10) time(0);
   		[!? tturnleft(T)] robotLeft speed(100) time (T); //girare a sinistra di 90°
   		//TODO start blink led
		actorOp startBlink;
		delay time(2000);
		//TODO fare una foto e mandarla alla console del radar (MQTT)
		[!? tturnright(T)] robotRight speed(100) time (T); //girare a destra di 90°
   		delay time(5000);
		//TODO stop blink led
		actorOp stopBlink;
		delay time(2000);
		//repeatPlan
   		resumeLastPlan
   	
	Plan waitRepositioning
		println("waitRepositioning");
		//TODO aspettare un evento 'reset' mandato da console 
		repeatPlan
	
	Plan primiPassi resumeLastPlan
	    println("primiPassi " )  ;
		robotForward speed(100) time(2000);
		delay time(1000);
		robotRight speed(100) time(2000); 
		delay time(1000);
		robotLeft speed(100) time (2000);
		delay time(1000);
 		robotBackward speed(100) time(5000);
    	println("primiPassi END")
    	             
	Plan reactToUsercmd resumeLastPlan  
		println("reactToUsercmd in robot_actor" ) 
		        
	Plan reactToEvent          
		println("reactToEvent in robot_actor" ) ;   
		printCurrentEvent ;     
		[ ?? stored( Ev,line(X,POS) ) ] println ("stored( Ev,line(X,POS)");//println("---> line("+ X + "," + POS +") " );    
		[ ?? stored( Ev,distance(X,POS,SIDE) ) ] println ("stored( Ev,distance(X,POS,SIDE)") //println("--->" + X)    
	
	Plan doWork
		[ !? tforward(X) ] println("stored( Ev,distance(X,POS,SIDE)"); //println("r0 forward for " + X + " secs" );     
		//[ !? tforward(X) ] robotForward speed(1000) time(X)  react event usercmd -> reactToUsercmd  or event sensordata -> reactToEvent;   
		//[ !? tturn(X) ] robotLeft speed(1000) time(X)  react event usercmd -> reactToUsercmd  or event sensordata -> reactToEvent;     
		//[ !? tforward(X) ] robotForward speed(1000) time(X)  react event usercmd -> reactToUsercmd; 
   		println("doWork END ")
 		              
}     