RobotSystem robotSystem
                        
Event cmd : cmd(X)  //per lo start e per lo stop da console (pagina 23 del pdf per spiegazione)
Event sensordata : sensordata(X)  //from SensorObserver
Event reachedsensor : reachedsensor(X) 
Event obstacle : obstacle(X) //from red button (obstacle from console) and from SensorObserver
//Event endmove : endmove //from a robot move         

Event inputcmd       : usercmd(executeInput(CMD)) //per il run da console
Event alarm          : alarm( obstacle, p( Distance, Angle  ) )
Event sonar 		 : p( Distance, Angle ) 
Event numOfSonar  	 : numOfSonar( N )

Dispatch photograph  : ph(X) 

Context  ctxRadar      ip [ host="172.20.10.2" port=8033 ] -httpserver //192.168.137.1
EventHandler evhr for sonar, alarm, cmd, numOfSonar ;
Context  ctxSensorEmitter  ip [ host="172.20.10.3" port=8133 ] //Primo sonar del muro
//Context  ctxSensorEmitter  ip [ host="172.20.10.14" port=8133 ] //Secondo sonar del muro

Context ctxRobot ip [ host="172.20.10.14"  port=8079 ]
EventHandler evh for /*endmove,*/ alarm, obstacle, sensordata, cmd /*-print*/ { memo currentEvent for robot_actor };

QActor  radargui context ctxRadar {
	  	
	Rules {
		checknear( D,A ) :- eval( lt, D, 20 ), !, assert( obstacle(D,A) ). //TODO sostituire 20 con 40
		checknear( D,A ).
	}
	  
	Plan init normal         
		println("RADAR init the GUI ... ") ;     
		actorOp activateGui ;     
		switchToPlan doWorkMsgs      
	Plan doWorkMsgs 
		sense time(86400000) sonar -> continue ;
		switchToPlan checkObstacle ;
		onEvent sonar : p(D,A) -> actorOp sendDataToGui( D,A ) ; 
		repeatPlan  
	Plan checkObstacle resumeLastPlan
		onEvent sonar : p(D,A) -> demo checknear(D,A) ;
		[ ?? obstacle(D,A)  ] emit reachedsensor : reachedsensor(X) //il robot ha raggiunto il sensore, emetto un evento per avvisarlo
}

QActor alarmhandler context ctxRadar {
	
	Plan init normal        
		sense time(86400000) alarm -> continue;
 		onEvent alarm : alarm( obstacle, p(D,A) ) -> switchToPlan handleAlarm; //TODO questo evento deve essere emesso dove valuto l'espressione
		repeatPlan
	Plan handleAlarm resumeLastPlan
		println("alarm") ;
		sound time(2000) file('./audio/tada2.wav') 
}

QActor photoreceiver context ctxRadar {
	
	Plan init normal
        actorOp connectAndSubscribe ;
		switchToPlan doWork 
		
	Plan doWork
		receiveMsg time (86400000)  ; //one day
        printCurrentMessage ;
        onMsg photograph : ph(X) -> actorOp saveMqttPhoto(X) ; 
        println('Foto Ricevuta') ; 
        repeatPlan  
}

QActor sensorsonar context ctxSensorEmitter {
	  
	Rules {
		/* THESE RULES ARE WRITTEN IN THE WorldTheory of the sensorsonar */
		/* CONFIGURATION */
		onRaspberry.
		mysonar( s1, coloryellow, "172.20.10.12" ).
		//mysonar( s2, colorred, "172.20.10.14" ).   
		
    	//mysonar( s1, coloryellow, "192.168.137.2" ).  
    	//mysonar( s3, colorgreen, "192.168.251.120" ).       
 	
		/* RULES */
		sonar(s1,330).
		sonar(s2,30).
		//sonar(s3,150).  
    	numOfSonars(N) :- bagof(sonar(S,P), sonar(S,P), SonarList), length(SonarList,N).
    	setmyposition :- numOfSonars(N), assert( numOfSonars( N ) ), mysonar( SONAR, _, _ ), sonar( SONAR,POS ), assert( position( POS ) ).   
    	//obstacledata( p(D,POS) ) :- actorOpDone( _,D ), position(POS). //actorOpDone( _,d(D) ) TODO trovare un modo per passare solo la distanza e non tutta la stringa generata
	}

	Plan init normal     
		println("sensorsonar STARTS")  ;
    	[ !? onRaspberry ] actorOp startSonarC;
    	demo setmyposition ;  //depends on mysonar
    	[ !? position(POS) ] println( position(POS) );
    	[ !? numOfSonars(N) ]  println( numOfSonars(N) );
 		[ !? numOfSonars(N) ]  emit numOfSonar : numOfSonar(N) ;
    	[ !? onRaspberry ] switchToPlan workReal 
	Plan workReal 
		[ !? position(POS) ] actorOp getDistanceFromSonar(POS) ; //(1)  //Dati reali prelevati dal sensore
		[ ?? obstacledata( D,POS )] emit sonar : p(D,POS) ;
    	repeatPlan
}

Robot ioRobot QActor robot_actor context ctxRobot /*-i*/{
	          
	Rules {           
		tforward(10000).
		tturnright(350).
		tturnleft(300).
	}
	
	Plan init normal
		actorOp connectToSend ;
		actorOp createPi4jLed(23) ;
		actorOp createPiCamera ;
 		println("-------------");
 		println("ioRobot: A robot performs a move in reactive way (usercmd)"  )  ;
		println("The moves can be stopped by pressing a button on the http GUI"  )  ;
		println("-------------");
		switchToPlan startWalking;
  		println("---- FINE ----")
  		
  	Plan startWalking resumeLastPlan
   		println("startWalking");
   		//TODO aggiungere reazione a stop da console (usercmd)
   		[!? tforward(T)] robotForward speed(100) time(T) ; //react event obstacle -> stopWalking ; //or event alarm -> reachedSensor;
   		//switchToPlan waitRepositioning ;
   		switchToPlan reachedSensor ;
   		switchToPlan stopWalking

	Plan stopWalking
		println("stopWalking");
		robotStop speed(1) time(1);
		println("ioRobot stopped");
		switchToPlan waitRepositioning

	Plan reachedSensor resumeLastPlan
		println("reachedSensor");
		robotStop speed(10) time(0);
		[!? tturnleft(T)] robotLeft speed(100) time (T); //girare a sinistra di 90°
		actorOp startBlink;
		delay time(2000);
		actorOp sendMsgMqtt ;
		[!? tturnright(T)] robotRight speed(100) time (T); //girare a destra di 90°
		delay time(5000);
		actorOp stopBlink;
		delay time(2000)
   	
	Plan waitRepositioning
		println("waitRepositioning");
		sense time(86400000) cmd -> continue;
		onEvent cmd : cmd(start) -> switchToPlan startWalking ;
		repeatPlan
		        
}     