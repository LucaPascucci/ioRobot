RobotSystem robotSystem
                        
Event cmd : cmd(X)  //per lo start e per lo stop da console (pagina 23 del pdf per spiegazione)
Event sensordata : sensordata(X)  //from SensorObserver
Event reachedsensor : reachedsensor(X) 
Event obstacle : obstacle(X) //from red button (obstacle from console) and from SensorObserver       

Event inputcmd       : usercmd(executeInput(CMD)) //per il run da console
Event alarm          : alarm( obstacle, p( Distance, Angle  ) )
Event sonar 		 : p( Distance, Angle ) 
Event numOfSonar  	 : numOfSonar( N )

Dispatch photograph  : ph(X) 

Context  ctxRadar      ip [ host="172.20.10.2" port=8033 ] -httpserver //192.168.137.1
EventHandler evhr for sonar, alarm, cmd, numOfSonar ;
Context  ctxSensorEmitter  ip [ host="172.20.10.3" port=8133 ] //Primo sonar del muro
//Context  ctxSensorEmitter  ip [ host="172.20.10.14" port=8133 ] //Secondo sonar del muro

Context ctxRobot ip [ host="172.20.10.14"  port=8079 ]
EventHandler evh for alarm, obstacle, sensordata, cmd { memo currentEvent for robot_actor };

QActor radargui context ctxRadar {
	  	
	Rules {
		checknear( D,A ) :- eval( lt, D, 20 ), !, assert( obstacle(D,A) ). //TODO sostituire 20 con 40
		checknear( D,A ).
	}
	  
	Plan init normal  
		actions[
			println("RADAR init the GUI ... ") ;	
			actorOp activateGui
		]        
		switchTo doWorkMsgs     
	
	Plan doWorkMsgs 
		actions[
			println("doWorkMsgs")
		]
		transition 
		whenTime 86400000 -> doWorkMsgs
		whenEvent sonar -> checkObstacle
		
	Plan checkObstacle
		actions[
			println("checkObstacle") ;
			onEvent sonar : p(D,A) -> actorOp sendDataToGui( D,A ) ;
			onEvent sonar : p(D,A) -> demo checknear(D,A) ;
			[ ?? obstacle(D,A)  ] emit reachedsensor : reachedsensor(X)  //il robot ha raggiunto il sensore, emetto un evento per avvisarlo	 
		]  
		switchTo doWorkMsgs
	
}

QActor alarmhandler context ctxRadar {
	
	Plan init normal
		actions[
			println("init alarmhandler")
		]   
		transition
		whenTime 86400000 -> init
		whenEvent alarm -> handleAlarm //TODO questo evento deve essere emesso dove valuto l'espressione
		
	Plan handleAlarm resumeLastPlan
		actions[
			println("alarm") ;
			sound time(2000) file('./audio/tada2.wav')	
		] 
		switchTo init
}

QActor photoreceiver context ctxRadar {
	
	Plan init normal
		actions[
			actorOp connectAndSubscribe
		] 
		switchTo doWork
		
	Plan doWork
		actions[
			println("doWork")
		]
		transition 
		whenTime 86400000 -> doWork
		whenMsg photograph -> savePhoto  
        
	Plan savePhoto
		actions[
			printCurrentMessage ;
			onMsg photograph : ph(X) -> actorOp saveMqttPhoto(X) ; 
        	println('Foto Ricevuta')  
		]
		switchTo doWork
}

QActor sensorsonar context ctxSensorEmitter {
	  
	Rules {
		/* THESE RULES ARE WRITTEN IN THE WorldTheory of the sensorsonar */
		/* CONFIGURATION */
		mysonar( s1, coloryellow, "172.20.10.12" ).
		//mysonar( s2, colorred, "172.20.10.14" ).   
		
    	//mysonar( s1, coloryellow, "192.168.137.2" ).  
    	//mysonar( s3, colorgreen, "192.168.251.120" ).       
 	
		/* RULES */
		sonar(s1,330).
		sonar(s2,30).
		//sonar(s3,150).  
    	numOfSonars(N) :- bagof(sonar(S,P), sonar(S,P), SonarList), length(SonarList,N).
    	setmyposition :- numOfSonars(N), assert( numOfSonars( N ) ), mysonar( SONAR, _, _ ), sonar( SONAR,POS ), assert( position( POS ) ).   
    	//obstacledata( p(D,POS) ) :- actorOpDone( _,D ), position(POS). //actorOpDone( _,d(D) ) TODO trovare un modo per passare solo la distanza e non tutta la stringa generata
	}

	Plan init normal
		actions[
			println("sensorsonar STARTS")  ;
    		actorOp startSonarC ;	
    		demo setmyposition ;
    		[ !? position(POS) ] println( position(POS) ) ;
    		[ !? numOfSonars(N) ]  println( numOfSonars(N) ) ;
 			[ !? numOfSonars(N) ]  emit numOfSonar : numOfSonar(N) 
		]
		switchTo workReal
    	 
	Plan workReal 
		actions[
			[ !? position(POS) ] actorOp getDistanceFromSonar(POS) ; //(1)  //Dati reali prelevati dal sensore
			[ ?? obstacledata( D,POS )] emit sonar : p(D,POS)
		]
		switchTo workReal
}

Robot ioRobot QActor robot_actor context ctxRobot {
            
	Rules {           
		tforward(10000).
		tturnright(350).
	    tturnleft(300).
	 }
	  
	 Plan init normal 
		actions [
	    	actorOp connectToSend;
	      	actorOp createPi4jLed(23) ;
	      	actorOp createPiCamera ;
	      	println("-------------");
	      	println("ioRobot: A robot performs a move in reactive way"  );
	      	println("-------------")
	    ]
	    switchTo startWalking
	    
	Plan startWalking //resumeLastPlan
		actions [
	    	println("startWalking")
		]
	    reactive [!? tforward(T)] robotForward speed(100) time(T)
	    whenEnd          	  		  -> startWalking
	    whenTout 12000        		  -> handleTout
	    whenEvent obstacle    		  -> stopWalking
	    or whenEvent reachedsensor    -> reachedSensor
	    or whenEvent cmd    		  -> stopWalking
	    or whenEvent alarm 			  -> stopWalking
	
	Plan stopWalking
		actions [
	    	println("stopWalking");
	    	robotStop speed(1) time(1);
	    	println("ioRobot stopped")
	    ]
	    switchTo waitRepositioning
	
	Plan reachedSensor
		actions [
	    	println("reachedSensor");
	      	robotStop speed(10) time(0);
	      	[!? tturnleft(T)] robotLeft speed(100) time (T); //girare a sinistra di 90°
	      	delay time(2000);
	      	actorOp startBlink;
	      	actorOp sendMsgMqtt ;
	      	delay time(2000);
	      	[!? tturnright(T)] robotRight speed(100) time (T); //girare a destra di 90°
	      	delay time(2000);
	      	actorOp stopBlink
	    ] 
	    switchTo startWalking
	     
	Plan waitRepositioning
		actions [
	    	println("waitRepositioning")
	    ]
	    transition
	    whenTime 86400000 -> waitRepositioning
	    whenEvent cmd -> startWalking // per l'evento start ricevuto da console
    
    Plan handleTout
    	actions [
    		println("timeout")
    	]
}    